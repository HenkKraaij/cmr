\documentclass[12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[utf8]{inputenc}
\usepackage[usenames,dvipsnames]{color}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{natbib}
\usepackage{pgfplots}
\usepackage{colortbl}
\usepackage{booktabs}

% layout
\oddsidemargin 5mm
\textwidth 150mm

\topmargin 0mm
\textheight 20cm

\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\BG}[1]{\ensuremath{\mathrm{BG}(#1)}}
\newcommand{\M}[1]{\ensuremath{\mathrm{M}(#1)}}
\newcommand{\G}[1]{\ensuremath{\mathrm{G}(#1)}}
\newcommand{\Cpp}{{\em C++ }}
\newcommand{\Polymake}{{\em polymake }}
\newcommand{\Boost}{{\em Boost C++ Libraries}}

\pgfkeys{/pgf/number format/.cd,fixed,precision=2,zerofill=true}

\begin{document}
\topmargin 20mm
\pagestyle{empty}


\title{\huge \bf Testing Total Unimodularity}

\date{July 2010}
\author{Matthias Walter\\ Department of Mathematics/IMO, \\ University of Magdeburg}

\maketitle

\begin{abstract}
A real matrix $A \in \R^{m \times n}$ is called totally unimodular, if any square submatrix
has a determinant of either $0$, $-1$ or $+1$. By submatrices we mean any matrix that can be obtained from
the original by a sequence of row/column deletions. In particular, the $1 \times 1$ submatrices
are required to satisfy the property, restricting the ground set to $A \in \{-1, 0, 1\}^{m \times n}$.

The importance of total unimodularity comes from the fact, that if a solution of
a linear equation $A x = b$ for $b \in \Z^m$ exists, there also exists an integral one due to Cramer's rule. As any vertex
of a polyhedron $P = \{ x : Ax \leq b \}$ is a solution to a subsystem of linear equations,
$P$ is known to be integral, if $A$ is totally unimodular and $b$ integral.

This document introduces a toolkit to test matrices for total unimodularity in different ways,
the main one being a variant of the polynomial-time algorithm proposed in \cite{Truemper90V}.
We explain usage of a \Cpp library, a \Polymake extension and show benchmark results for the implemented methods.

\end{abstract}

\bigskip

\section*{Overview}

The toolkit is mostly about an efficient implementation of a matroid-based algorithm for testing total unimodularity.
As the algorithm certifies the binary answer via matroids, one might want to understand some basic concepts beforehand.

In the first section we introduce the relevant definitions. Sections 2 and 3 are dedicated to the \Cpp library
and the \Polymake extension, while the 4th section shows benchmark results for different types of matrices.

\newpage

\topmargin 0mm
\pagestyle{plain}
\parindent 5mm

\section{Important concepts}

Throughout the whole document, we talk about integer matrices. By submatrices we mean parts of matrices
that are induced by any subset of the row indicies and any subset of the column indices. A matroid
$(E, \mathcal{I})$ is a groundset with a connected set of {\em independent} subsets $I \in \mathcal{I}$
having the following properties:
\begin{enumerate}
\item[(i)]
  $\emptyset \in \mathcal{I}$
\item[(ii)]
  $A \in \mathcal{I} ~~\Rightarrow~~ \forall B \subseteq A : B \in \mathcal{I}$
\item[(iii)]
  Let $A,B \in \mathcal{I}$ with $|A| < |B|$, then $\exists e \in B \setminus A : A \cup \{e\} \in \mathcal{I}$
\end{enumerate}

The most prominent example for a matroid is the set of vectors in a vector space, where those sets of vectors are independent
that are linearly independent. For us, the so called {\em graphic matroids} are interesting. They are defined as the edge sets
of an undirected graph, where such a set is independent if and only if it forms a forest.

Some matroids can be {\em represented} over a field $\mathcal{F}$, meaning that there exists some vector matroid over $\mathcal{F}$
with exactly the same matroid structure.
As the maximal independent sets in each matroid (which are called {\em bases}) all have the same size $m$, a matroid with $|E| = n$ that is representable over $\mathcal{F}$
can be represented via an $m \times n$ matrix over $\mathcal{F}$, where the $n$ columns correspond to the elements and the rank of a submatrix decides whether
the columns inducing it are (linearly) independent. Via Gaussian elemination, one can always arrange the matrix
such that it has an $m \times m$ identity submatrix, which can be truncated, as it does not contain information anymore.
In this way, a vector matroid is represented by an $(n-m) \times n$ matrix having a basis $X \subset E$ as row indices and
$Y := E \setminus X$ as column elements.

{\em Regular} matroid are those that are representable over every field.
It turns out that the regular matroids are exactly the ones whose binary representation matrix
can be signed (i.e. some $1$ entries substituted by $-1$ entries) to be totally unimodular.

The last concepts necessary for understanding the certificate for total unimodularity are about
composition and decomposition of matroids. A $k$-separation of a matroid
represented by the matrix $B$ with row indices $X$ and column indices $Y$ is a partition
of $X$ and $Y$ into $X = X_1 \cup X_2$ and $Y = Y_1 \cup Y_2$ with the following properties:
\begin{enumerate}
\item[(i)]
  $|X_i \cup Y_i| \geq k$ for $i = 1,2$
\item[(ii)]
  $\mathrm{rk}_2 (B_{X_1, Y_2}) + \mathrm{rk}_2 (B_{X_2, Y_1}) = k-1$ with $\mathrm{rk}_2$ being the rank function on $\mathrm{GF}(2)$
\end{enumerate}
A matroid is $k$-connected if and only if it does not have a $k'$-separation for $1 \leq k' < k$. A $k$-composition
is way of glueing two matroids together by putting $k$ elements of both together, such that the
representation matrix has a $k$-separation with the two original representation matrices
as the partitioning submatrices. A decomposition is the reversed process of composition.

According to Seymours decomposition theorem for regular matroids every 3-connected
regular matroid must be graphic, cographic ($B^t$ represents a graphic matroid), is isomorphic to a special matroid $R_{10}$
elements or has a 3-separation of a certain kind. Because $k$-composition ($k=1,2,3$) maintains
regularity, a decomposition approach yields a polynomial-time algorithm:
It establishes it's result by dropping the signs of the given matrix
and interpreting it as a binary matroid which is then decomposed into simpler components.

If the matroid is not regular, we end up with a 3-connected part that has no $3$-separation
which could be used to decompose it further. The algorithm must perform a signing prodedure to ensure that
the binary matrix can be signed appropriately to result in the original matrix.

If the algorithm asserts that a given matrix is totally unimodular, it can thus return a decomposition-tree,
whose inner nodes represent $k$-separations and whose leafs are graphic, cographic or $R_{10}$ matroids. In the other case,
it will remove sets of rows/columns such that the resulting matrix is still not totally unimodular, 
until each removal of a single row or column results in a totally unimodular matrix. Obviously the matrix itself must have
the wrong determinant and can be returned as a violator.

\section{The \Cpp library}

The \Cpp library is the heart of the implementation.
The frontend program attached to it simply uses it, as well as the \Polymake extension does.
The interface depends on {\tt boost::numeric::ublas::matrix} which is a matrix template from the \Boost \cite{Boost}.
The interface belonging to the main algorithm has variants for the certified versions. In face you can test matrix
for total unimodularity with or without positive and/or negative certificates. To use it, you just need to include one header.

\subsection{Installing}

To install the \Cpp library, either take a look at the most recent version at the download page at
\url{http://github.com/xammy/tu-test/downloads} or use Git to clone the repository:

{\tiny
\lstset{language=Bash,basicstyle=\small\ttfamily,emph={\$}, emphstyle=\color{blue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
$ git clone git@github.com:xammy/tu-test.git
\end{lstlisting}}

\parindent 0mm
After unzipping (if necessary) and going into the freshly created directory, do the following to setup and compile the library:

{\tiny
\lstset{language=Bash,basicstyle=\small\ttfamily,emph={\$}, emphstyle=\color{blue}}
\begin{lstlisting}
$ ./autogen.sh
...
$ ./configure
...
$ make
...
$ ./src/tu  -h
Usage: ./src/tu [OPTIONS] [--] MATRIX_FILE
Options:
 -h Shows a help message.
 -c Prints certificates: A matroid decomposition if the matrix is totally unimodular and a violating submatrix otherwise.
 -u Updating logging (default).
 -v Verbose logging.
 -q No logging at all.
$ su
Password: 
(root) $ make install
...
\end{lstlisting}}

Before becoming root, everything should be compiled, which is tested via the console tool.
The library depends on the \Boost \cite{Boost}, which must be installed on your system. If you cannot get it to work and
only need the console tool, you can download the ``noboost''-package or checkout the ``noboost'' branch in the Git repository.

\subsection{Important types}

The following types are of interest as they are used as parameter types for the routines.

\subsubsection{tu::integer\_matrix}

This {\em typedef} is a shortcut for {\tt boost::numeric::ublas::matrix} for integral values and is used
to represent the matrices to be tested for total unimodularity.

\subsubsection{tu::submatrix\_indices}

This {\em struct} is just a pair of {\tt indirect\_array} objects, which represent row and
column indices of a submatrix.

\subsubsection{tu::integer\_submatrix}

This {\em typedef} is a shortcut for {\tt boost::numeric::ublas::matrix\_indirect} and is used
to represent a submatrix of a {\tt tu::integer\_matrix} indexed by {\tt tu::submatrix\_indices}.

\subsubsection{tu::decomposed\_matroid}

This {\em abstract class} represents a node in the decomposition tree.

\subsubsection{tu::decomposed\_matroid\_leaf}

If the result of the method {\tt tu::decomposed\_matroid::is\_leaf()} is {\tt true} for an object, it can be cast
to this type to find out the type of the leaf. If the represented matroid is (co)graphic, it's (co)graph
can also be inspected.

\subsubsection{tu::decomposed\_matroid\_separator}

If the result of the method {\tt tu::decomposed\_matroid::is\_leaf()} is {\tt false} for an object, it can be cast
to this type to find out the type of the separation and the minors it is separated into.

\subsubsection{tu::log\_level}

This {\em enum} can be used to make the routines more or less verbose. It's values are:
\begin{itemize}
\item[LOG\_QUIET]
  Does not print anything
\item[LOG\_UPDATING]
  Prints the current status and history of decomposition in an updating manner, which is pretty in a terminal. Do not use this when logging to a file.
\item[LOG\_VERBOSE]
  Prints the decomposition history line by line.
\end{itemize}

\newpage

\subsection{API}

The list of important routines follows:

\subsubsection{is\_totally\_unimodular}

{\bf Synopsis} 

{\tiny
\lstset{language=C++,basicstyle=\small\ttfamily,keywordstyle=\color{Maroon},commentstyle=\color{Blue},stringstyle=\color{Green},showstringspaces=false,emph={bool,int,unsigned,char,true,false,void}, emphstyle=\color{blue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
bool is_totally_unimodular (
    const integer_matrix& matrix,
    log_level level = LOG_QUIET);

bool is_totally_unimodular (
    const integer_matrix& matrix,
    decomposed_matroid*& decomposition,
    log_level level = LOG_QUIET);

bool is_totally_unimodular (
    const integer_matrix& matrix,
    submatrix_indices& violator,
    log_level level = LOG_QUIET);

bool is_totally_unimodular (
    const integer_matrix& matrix,
    decomposed_matroid*& decomposition,
    submatrix_indices& violator,
    log_level level = LOG_QUIET);
\end{lstlisting}}

{\bf Description}

\vspace{2mm}
Takes an integer matrix, tests it for being a totally unimodular, returning the result as a {\em bool}.
It also possibly computes certificates for the correctness of the answer. Namely a matroid decomposition is set up,
if the given matrix is totally unimodular. If not, 2 versions will find a violating submatrix. This search requires
some extra work and can take more time.

\subsubsection{decompose\_binary\_matroid}

{\bf Synopsis} 

{\tiny
\lstset{language=C++,basicstyle=\small\ttfamily,keywordstyle=\color{Maroon},commentstyle=\color{Blue},stringstyle=\color{Green},showstringspaces=false,emph={bool,int,unsigned,char,true,false,void}, emphstyle=\color{CornflowerBlue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
decomposed_matroid* decompose_binary_matroid (
    const integer_matrix& matrix,
    log_level level = LOG_QUIET);
\end{lstlisting}}

{\bf Description}

\vspace{2mm}
Takes an integer matrix, tests it for being a 0-1-matrix and constructs a matroid-decomposition
of the binary matroid represented by it. Returns a decomposition tree or {\em NULL}, if it is no
0-1-matrix.

\subsubsection{determinant\_is\_totally\_unimodular}

{\bf Synopsis} 

{\tiny
\lstset{language=C++,basicstyle=\small\ttfamily,keywordstyle=\color{Maroon},commentstyle=\color{Blue},stringstyle=\color{Green},showstringspaces=false,emph={bool,int,unsigned,char,true,false,void}, emphstyle=\color{blue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
bool determinant_is_totally_unimodular (
    const integer_matrix& matrix);

bool determinant_is_totally_unimodular (
    const integer_matrix& matrix, submatrix_indices& violator);
\end{lstlisting}}

{\bf Description}

\vspace{2mm}
Takes an integer matrix, tests it for being a totally unimodular by examining all subdeterminants, returning the result as a {\em bool}.
It also possibly computes a certificate for the correctness of the ``no''-answer. This routine is very inefficient and
should not be used for matrices bigger than $10 \times 10$.

\subsubsection{ghouila\_houri\_is\_totally\_unimodular}

{\bf Synopsis} 

{\tiny
\lstset{language=C++,basicstyle=\small\ttfamily,keywordstyle=\color{Maroon},commentstyle=\color{Blue},stringstyle=\color{Green},showstringspaces=false,emph={bool,int,unsigned,char,true,false,void}, emphstyle=\color{blue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
bool ghouila_houri_is_totally_unimodular (
    const integer_matrix& matrix);
\end{lstlisting}}

{\bf Description}

\vspace{2mm}
Takes an integer matrix, tests it for being a totally unimodular via the criterion of Ghouila \& Houri, returning the result as a {\em bool}.
This routine is inefficient and should not be used for matrices bigger than $25 \times 25$.

\subsection{Using the library}

The following example illustrates the usage of the \Cpp library.

{\tiny
\lstset{language=C++,basicstyle=\small\ttfamily,keywordstyle=\color{Maroon},commentstyle=\color{Blue},stringstyle=\color{Green},showstringspaces=false,emph={bool,int,unsigned,char,true,false,void}, emphstyle=\color{blue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
#include <iostream>
#include "total_unimodularity.hpp"

int main(int argc, char* argv[])
{
  // Create a 2 x 3 matrix:
  // 1  1 -1
  // 1  0  1
  tu::integer_matrix matrix (2, 3);
  matrix(0,0) = 1; // Make this a -1 to have it t.u.
  matrix(0,1) = 1;
  matrix(0,2) = -1;
  matrix(1,0) = 1;
  matrix(1,1) = 0;
  matrix(1,2) = 1;

  tu::submatrix_indices indices;
  bool result = tu::is_totally_unimodular (matrix, indices);

  if (result)
    std::cout << "Matrix is t.u." << std::endl;
  else
  {
    std::cout << "Matrix is NOT t.u." << std::endl;
    std::cout << "Rows:";
    for (size_t i = 0; i < indices.rows.size(); ++i)
      std::cout << " " << indices.rows[i];
    std::cout << "\nColumns:";
    for (size_t i = 0; i < indices.columns.size(); ++i)
      std::cout << " " << indices.columns[i];
    std::cout << std::endl;
  }

  return 0;
}
\end{lstlisting}}

\subsection{The console tool}

Together with the library, a small tool will be compiled. It can be used to read a single matrix from a file and test it for total unimodularity.
The file format is as follows.

\begin{table}[h]
\centering\begin{tabular}{|ccc|}
\hline
2 & 3 & \\
&& \\
1 & 1 & -1 \\
1 & 0 & 1 \\\hline
\end{tabular}
\caption{An example file to encode a $2 \times 3$ matrix.}
\end{table}

When having the matrix in such a format, it is straightforward to test it for total unimodularity.

{\tiny
\lstset{language=Bash,basicstyle=\small\ttfamily,emph={\$}, emphstyle=\color{blue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
$ cat example.mat 
2 3

1 1 -1
1 0  1
$ ./src/tu -c example.mat 
(2 x 3) -1/0/+1 OK, SIGNING FAILED


The 2 x 3 matrix is not totally unimodular.

The violating submatrix (det = 2) is 2 x 2:

   1  -1
   1   1

Row indices in range [0,1]:
0 1

Column indices in range [0,2]:
0  2 

\end{lstlisting}}

\section{The \Polymake extension }

There is also an extension to the \Polymake \cite{Polymake} system which can be used to test matrices in \Polymake
for total unimodularity, possibly giving a violating submatrix. As the effort to add objects for
the matroid decomposition tree to \Polymake is too big, there is no way to obtain a certificate for
an affirmative answer.

\subsection{Installing}

As for the \Cpp library, one can either download the \Polymake extension from 
\url{http://github.com/xammy/tu-test/downloads} or use Git to clone the repository:

{\tiny
\lstset{language=Bash,basicstyle=\small\ttfamily,emph={\$}, emphstyle=\color{blue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
$ git clone git@github.com:xammy/tu-test.git -b polymake
\end{lstlisting}}

After that, start \Polymake and import the extension:

{\tiny
\lstset{language=Bash,basicstyle=\small\ttfamily,emph={\$}, emphstyle=\color{blue},emph={[2]\#include,\#define,\#ifdef,\#endif}, emphstyle={[2]\color{blue}}}
\begin{lstlisting}
$ polymake 
...
polytope > import_extension ("~/tu-test/");
polymake:  WARNING: Recompiling shared module for application common,
 please be patient...

polytope > help "is_totally_unimodular";
functions/is_totally_unimodular:
is_totally_unimodular(matrix) -> Bool

 Tests a given matrix for total unimodularity, without certificates.

Arguments:
  Matrix<int> matrix 

Returns Bool 

-----
is_totally_unimodular(matrix, row_indices, column_indices) -> Bool

 Tests a given matrix for total unimodularity, setting row/column
 indices to a violating submatrix if the result is negative.

Arguments:
  Matrix<int> matrix 
  Vector<int> row_indices of violating submatrix.
  Vector<int> column_indices of violating submatrix.

Returns Bool 


polytope > exit;
$
\end{lstlisting}}

The library depends on the \cite{Boost}, which must be installed on your system.
Unlike the console tool, there is no way around it, except installing it.

\newpage

\section{Benchmark results}

There are different types of matrices for which the different methods achieve different running times. We present results for the Ghouila-Houri method {\em GH}, the
determinant-based method {\em D} and the matroid-based algorithm {\em M}. All measurements were on an Intel Core i5 M 520, running on 2.4 GHz.

\subsection{Random matrices}

The simplest type of $-1,0,+1$-matrix is a random one.
Our algorithm starts by testing whether the support matrix of the input matrix can be signed in a specific way back to the original matrix.
As those random matrices are almost always not t.u., we modify them such that they have this sign-property.
Testing for signedness takes nearly no time compared to the main algorithm and we are interested in how good the latter performs on these.

\begin{table}[h]
  \begin{center}
  \pgfplotstabletypeset[
columns/height/.style={column name={\footnotesize Height}},
columns/width/.style={column name={\footnotesize Width}},
columns/matroid/.style={column name={\footnotesize Matroid ($s$)}},
columns/matroid+cert/.style={column name={\footnotesize Matroid w/cert. ($s$)}},
columns/gh/.style={column name={\footnotesize Ghouila-Houri ($s$)}},
columns/det/.style={column name={\footnotesize Determinant ($s$)}},
every even row/.style={before row={\rowcolor[gray]{0.9}}},
every head row/.style={before row=\toprule,after row=\midrule},
every last row/.style={after row=\bottomrule},
columns/matroid/.style={empty cells with={$> 3600$}},
columns/matroid+cert/.style={empty cells with={$> 3600$}},
columns/height/.append style={precision=0},
columns/width/.append style={precision=0},
columns/det/.style={empty cells with={N/A}},
]{rnd.dat}
  \end{center}
  \caption{Performance for random matrices}
\end{table}

The determinant-based implementation uses {\em int}-based bitsets as a datastructure
and hence does not work for matrices with more rows/columns than the bit-size of the architecture.
The N/A entries indicate that the implementation is not capable of handling these matrices.
But we hope that the results in the next section convince the reader that improving the implementation
is probably a waste of time.

\newpage

\subsection{Network matrices}

To have test instances matrices that are totally unimodular,
we implemented a generator for random network matrices.
It generates a directed graph of a certain size, finds a spanning tree and derives the corresponding network matrix from these two.

\begin{table}[h]
  \begin{center}
  \pgfplotstabletypeset[
columns/height/.style={column name={\footnotesize Height}},
columns/width/.style={column name={\footnotesize Width}},
columns/matroid/.style={column name={\footnotesize Matroid ($s$)}},
columns/matroid+cert/.style={column name={\footnotesize Matroid w/cert. ($s$)}},
columns/gh/.style={column name={\footnotesize Ghouila-Houri ($s$)}},
columns/det/.style={column name={\footnotesize Determinant ($s$)}},
every even row/.style={before row={\rowcolor[gray]{0.9}}},
every head row/.style={before row=\toprule,after row=\midrule},
every last row/.style={after row=\bottomrule},
empty cells with={$> 3600$},
columns/height/.append style={precision=0},
columns/width/.append style={precision=0},
]{net.dat}
  \end{center}
  \caption{Performance for network matrices}
\end{table}

\subsection{Complementary totally unimodular matrices}

In \cite{Truemper98} complementary totally unimodular matrices are introduced. They have some interesting properties, although we only want to mention that they are t.u. and
can be made non-t.u. be adding a single row and a single column. Furthermore this augmented matrix has exactly one violating submatrix (an single entry having absolute value of 2),
which can be ``hidden'' by pivoting. Those are considered very tough examples, as finding the single violator is impossible by any enumeration-based scheme, even if that uses heuristics.

Unfortunately we were only able to generate c.t.u. matrices of small size. (less than $50 \times 50$) Those were still tested in some milliseconds and not included in our benchmark results.

\section{Conclusions}

The first obvious result is that the matroid-based implementation superseedes the determinant-based implementation for random and for network matrices,
as well as the Ghouila-Houri-based for network matrices only.
The latter performs so well on random matrices because there are many violators.
This can be verified by computing certificates for many such matrices, which almost always yields a $3 \times 3$ or $4 \times 4$ violator.

The determinant-based algorithm is basically useless for any practical purpose, while the Ghouila-Houri-based algorithm reveals its exponential running-time behaviors slighty later.
Our implementation is not only efficient in theory. The experiments show that it can be effectively used for matrices up to $100 \times 100$ and makes testing of $1000 \times 1000$ matrices
possible in running times less than a day.

In addition, it is much more complete as it can print certificates that prove the result. This property lets the library user verify the results without the need to read lots of source code.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
